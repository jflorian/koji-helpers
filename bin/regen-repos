#!/bin/sh

# Copyright 2016 John Florian <jflorian@doubledog.org>
#
# This file is part of koji-helpers.
#
# koji-helpers is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version so long as this copyright notice remains intact.
#
# koji-helpers is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# koji-helpers.  If not, see <http://www.gnu.org/licenses/>.

SELF=$(basename "$0")

# Set defaults.
REST_SECS=1800
WAIT_REPO=120

# Override per the configuration.
source "/etc/koji-helpers/${SELF}.conf"

# Source the shared function library.
source '/usr/libexec/koji-helpers/_shared'

# Other constants.
DELIM=' '
REPOS_CONF='/etc/koji-helpers/repos.conf'
STATE_DIR='/var/lib/koji-helpers/regen-repos'


checksum_of() {
    # Return a message digest checksum for a recursive "view" of package
    # repository data of some target directory structure such that iff the
    # contents change in any way, so does the returned checksum.
    local target="${EXT_REPO_ROOT}/$1"
    [ -d "$target" ] \
        || fail "cannot checksum non-existent directory '${target}'."
    find -L "$target" -path '*/repodata/*' -type f \
        | xargs md5sum | md5sum | cut -f1 -d' '
}

load_state() {
    # Return the checksum for the specified tag and directory name which was
    # previously saved with save_state().
    local tag="$1"
    local dir="$2"
    local state="${STATE_DIR}/${tag}"
    [ -e "$state" ] && grep "||${dir}||" "$state" | cut -f2 -d"$DELIM"
}

save_state() {
    # Store the given checksum persistently for the specified tag and
    # directory name to be retrieved later by load_state().
    local tag="$1"
    local dir="$2"
    local sum="$3"
    local tmp state
    tmp=$(mktemp -t "${SELF}-XXXX") || fail 'Cannot create tmp directory.'
    state="${STATE_DIR}/${tag}"
    [ -e "$state" ] && grep -v "||${dir}||" "$state" > "$tmp"
    printf "||%s||${DELIM}%s\n" "$dir" "$sum" >> "$tmp"
    mv "$tmp" "$state"
}

regen_all_repositories() {
    # Iterate over each listed buildroot dependency configuration and
    # regenerate the Koji repositories for them.
    local dependency ext_repo new_chksum old_chksum
    debug 'Started regeneration of all repositories with mutated external dependencies.'
    config_lines $REPOS_CONF | while IFS=: read -a dependency
    do
        local tag=${dependency[0]}
        local triggers=0
        debug "Checking dependencies for '${tag}'."
        for ext_repo in "${dependency[@]:1}"
        do
            new_chksum=$(checksum_of "$ext_repo")
            old_chksum=$(load_state "$tag" "$ext_repo")
            debug "'${ext_repo}' checksum '${old_chksum}' => '${new_chksum}'"
            if [[ "$old_chksum" != "$new_chksum" ]]
            then
                let triggers+=1
                debug "'${tag}' has changed dependency '${ext_repo}'."
                save_state "$tag" "$ext_repo" "$new_chksum"
            fi
        done
        if [ $triggers -gt 0 ]
        then
            info "Regenerating '${tag}' due to ${triggers} triggers."
            koji regen-repo "$tag" \
                || fail "Could not execute: koji regen-repo '${tag}'"
            if [ $WAIT_REPO -gt 0 ]
            then
                debug "Waiting up to ${WAIT_REPO} minutes for regeneration of '${tag}'."
                koji wait-repo --timeout=$WAIT_REPO "$tag" \
                    || fail "Could not execute: koji wait-repo '${tag}'"
            fi

        fi
    done
    debug 'Finished regeneration of all repositories with mutated external dependencies.'
}

main() {
    [ -n "$EXT_REPO_ROOT" ] \
        || fail 'EXT_REPO_ROOT must be configured.'
    while :
    do
        regen_all_repositories
        debug "Resting for ${REST_SECS} seconds."
        sleep $REST_SECS
    done
}

main "$@"
